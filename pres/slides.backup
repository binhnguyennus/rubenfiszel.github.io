[![asciicast](https://asciinema.org/a/twkwh0Wt2vAjMQFLu6fqGVWK7.png)](https://asciinema.org/a/twkwh0Wt2vAjMQFLu6fqGVWK7)


[![asciicast](https://asciinema.org/a/YCr4mxI2j90T0alUHZzHY56vv.png)](https://asciinema.org/a/YCr4mxI2j90T0alUHZzHY56vv)

# Important concepts

* The data flow is made of connected nodes.
* Nodes broadcast packets to the forward nodes at given virtual times
* Scheduler enforce that every packet is sent at the right virtual time and in the order
* Source emit packets, sink consume nodes

# Input and output nodes

- Input nodes can be clocks that emit packets at a regular interval
- Output nodes can be plots that show multiple timeseries coming from different nodes, calculate the RMSE, simply display the content, etc ...

![Plot](plot.png)

#

```
val sa: Source[A]
val sb: Source[B]
val sla: Source[List[A]]
def f(x: A): C
def b(x: A): Boolean

sa.map(f): Source[C]
sa.zip(sb): Source[(A, B)]
sab.unzip: (Source[A], Source[B])
sa.merge(sb): Source[Either[A, B]]
sa.fusion(sa): Source[A]
sa.foreach(f): Source[A]
sa.filter(b): Source[A]
sa.drop(n): Source[A]
sa.accumulate(clock): Source[List[A]]
sa.groupBy(A => B): Source[(B, A)]
sla.reduce(r): Source[A]
sa.takeWhile(b): Source[A]
sa.muted: Source[B]
sa.toTime: Source[Time]
sa.latency: Source[A]
sa.debug //print packets as they arrive
//and more ...
composable
sa.zip(sb).map(g).filter(c) ...
```


# Simulation

* possible to simulate fixed and random delays
* packets store the time they were initially emitted and, separately all the delays they encountered

# Buffering

Loop are possible through lazy val

```
val sa: Source[A]
def f(x: Source[(A, A)])
lazy val zp = sa.zip(buffer).map(f)
lazy val buffer = Buffer(zp)
def out = zp
```

# Spatial

![code gist link of an example of spatial blocks](http://paste.awesom.eu/jQsX)

# Batch 

* To integrate with spatial, we need some node to **batch process** the inputs instead of treating them as they arrive.
* To achieve that, we use multiple scheduler one for each batch and chain them
* **Problem**: what if a node have inputs from different nodes that have different scheduler ?

# 

* If not solved, packets may arrive out of order or never at all.
* Synchronize them by creating replays and transfer schedulers!
* The replay nodes are created where needed automatically at the graph creation. It is hidden from the user.

# Conclusion

Those tools made it infinitely easier to develop my particle filter, I hope you can find it useful too.

Thank you for your time and attention
